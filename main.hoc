//************************************************
// FILE NAME : main.hoc
// 2015.04.28
// Heewon Park
//************************************************

//************************************************
// MODIFICATION HISTORY
//************************************************
//
//
//


//************************************************
// FUNCTION LIST
//************************************************
// mkNetwork()
// mkCells()
// mkConnections()
// mkStimulations()
// setRecorder()
// setPrinter()
//************************************************
{load_file("nrngui.hoc")}
{load_file("stdlib.hoc")}
{load_file("CellSwc3.hoc")}
{load_file("loadinfo.hoc")}

strdef info_filename
info_filename = "./info/network_info_3cells.dat"
strdef info_filename_rn
info_filename_rn = "./info/network_info_10rns.dat"
//info_filename_rn = "./info/network_info_2000rns.dat"

objref pc
pc = new ParallelContext()

print "PC.NHOST ",pc.nhost
proc mkNetwork(){
    mkCells()
    mkConnections()
}

objref pns,lns,rns
proc mkCells(){localobj pn,ln,rn, nc, nil
    loadinfo(info_filename)
    loadinfo(info_filename_rn)
    NCELLS = NPN + NLN + NRN
    pns = new List()// projection neurons
    lns = new List()// local interneurons
    rns = new List()// receptor neurons
    
    print "NCELLS ",NCELLS
    for(i = pc.id; i < NCELLS; i+=pc.nhost){
	if(i<NPN){
	    j = i
	    pn = new CellSwc(pn_path[j].swcpath,pn_matrix.x[j][0],pn_matrix.x[j][1],pn_matrix.x[j][2])
	    pn.setPath(pn_path[j].ppath, pn_path[j].synpath)
	    pns.append(pn)
	    print "pn ", i, j
	    nc = pn.connect2target(0,nil)
	    //pns.o(0).mkSynapses("./synlist/fromRN/050622_4_sn_SynapseList.dat")

	}else if(i>=NPN && i<NPN+NLN){
	    j = i-NPN
	    ln = new CellSwc(ln_path[j].swcpath,ln_matrix.x[j][0],ln_matrix.x[j][1],ln_matrix.x[j][2])
	    ln.setPath(ln_path[j].ppath, ln_path[j].synpath)
	    lns.append(ln)
	    //if(j==0) ln.mkSynapses("./synlist/fromRN/040823_5_sn_SynapseList.dat")
	    //if(j==1) ln.mkSynapses("./synlist/fromRN/050205_7_sn_SynapseList.dat")
	    print "ln ", i, j
	    nc = ln.connect2target(0,nil)
	}else{
	    j = i-NPN-NLN
	    rn = new CellSwc(rn_path[j].swcpath,rn_matrix.x[j][0],rn_matrix.x[j][1],rn_matrix.x[j][2])
	    rn.getAxon()
	    rn.setPath(rn_path[j].ppath, rn_path[j].synpath)
	    print "SectionNumber " ,rn.SectionNum
	    rns.append(rn)
	    print "rn ", i, j, pc.id
	    nc = rn.connect2target(0,nil)
	}
	pc.set_gid2node(i,pc.id)
	pc.cell(i,nc)
    }
    pc.barrier()
}

{load_file("connect.hoc")}
proc mkConnections(){
    connectRNtoOthers()
    //connectLNtoLN()
    //connectPNtoLN()
    //connectLNtoPN()
}
mkNetwork()
print "NUMBER OF PROJECTION NEURONS :",pns.count()
print "NUMBER OF LOCAL INTERNEURONS :",lns.count()
print "NUMBER OF RECEPTOR NEURONS   :",rns.count()
//pns.o(0).mkSynapses("./synlist/fromRN/050622_4_sn_SynapseList.dat")
//lns.o(0).mkSynapses("./synlist/fromRN/040823_5_sn_SynapseList.dat")
loadSynapseInfo(pns.object(0))


//forsec rns.object(0).axonlist print secname()
//mkPreSynapseOnReceptor()

objref nclist
nclist = new List()
/*
proc connectRNtoLNPN(){local i
    gid_base = 1000000
    gid_cnt  = 0
    for(i=0; i<NPN+NLN; i+=1){
	if(!pc.gid_exists(j)){continue}
	print "i, base_gid", i, base_gid
	for j=0, nsyn-1{
	    target = pc.gid2cell(i)
	    syn_number = j
	    syn = target.synlist.object(syn_number)
	    nc = pc.gid_connect(gid_base+gid_cnt,syn)
	    gid_cnt  += 1
	    nc.delay  = 1
	    nclist.append(nc)
	}
    }
}
*/
proc mkStimulations(){

}

proc setRecorder(){

}

tstop = 0
{pc.set_maxstep(10)}
stdinit()
{pc.psolve(tstop)}

proc setPrinter(){

}

{pc.runworker()}
{pc.done()}
quit()